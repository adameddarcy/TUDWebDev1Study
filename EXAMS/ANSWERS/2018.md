# Question 1

## A. Chat Application with Java Sockets

Outline a chat application built using Java Sockets that allows two users (you can refer to them as Client and Server) to send and receive String messages. The chat should continue until one user enters “Exit”. Use pointers to explain each line so as to demonstrate your understanding of the code.
(12 marks)

```java
// Server.java
import java.io.*;
import java.net.*;

public class Server {
    public static void main(String[] args) {
        try {
            // Create a server socket listening on port 12345
            ServerSocket serverSocket = new ServerSocket(12345);
            System.out.println("Server started. Waiting for a client...");

            // Accept a connection from a client
            Socket socket = serverSocket.accept();
            System.out.println("Client connected.");

            // Create input and output streams for communication
            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);

            // Communication loop
            String message;
            while (true) {
                message = in.readLine();  // Read message from client
                if (message.equalsIgnoreCase("exit")) break;  // Exit condition
                System.out.println("Client: " + message);
                out.println("Server: " + message);  // Echo message back to client
            }

            // Close resources
            in.close();
            out.close();
            socket.close();
            serverSocket.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

// Client.java
import java.io.*;
import java.net.*;

public class Client {
    public static void main(String[] args) {
        try {
            // Connect to the server running on localhost at port 12345
            Socket socket = new Socket("localhost", 12345);
            System.out.println("Connected to the server.");

            // Create input and output streams for communication
            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);
            BufferedReader userInput = new BufferedReader(new InputStreamReader(System.in));

            // Communication loop
            String message;
            while (true) {
                System.out.print("Enter message: ");
                message = userInput.readLine();  // Read message from user input
                out.println(message);  // Send message to server
                if (message.equalsIgnoreCase("exit")) break;  // Exit condition
                System.out.println(in.readLine());  // Read and print response from server
            }

            // Close resources
            in.close();
            out.close();
            socket.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```
Explanation:

Server.java:

- ServerSocket serverSocket = new ServerSocket(12345);: Initializes the server to listen on port 12345.
- Socket socket = serverSocket.accept();: Waits for a client connection.
- BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream())); and PrintWriter out = new PrintWriter(socket.getOutputStream(), true);: Create input and output streams.
- while (true): Infinite loop to continuously read messages from the client.
- if (message.equalsIgnoreCase("exit")) break;: Breaks the loop if the client sends "Exit".
- in.close(); out.close(); socket.close(); serverSocket.close();: Closes all resources.

Client.java:

- Socket socket = new Socket("localhost", 12345);: Connects to the server at localhost on port 12345.
- BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream())); and PrintWriter out = new PrintWriter(socket.getOutputStream(), true);: Create input and output streams.
- BufferedReader userInput = new BufferedReader(new InputStreamReader(System.in));: Reads user input from the console.
- while (true): Infinite loop to continuously read messages from the user and send them to the server.
- if (message.equalsIgnoreCase("exit")) break;: Breaks the loop if the user inputs "Exit".
- in.close(); out.close(); socket.close();: Closes all resources.


## B. Java Sockets Implementations

Several different implementations of Java Sockets are available, depending on the type of Sockets and transport protocols used. Outline the objects used in the three different implementations covered in the coursework. Describe exactly how each works and in what circumstances it might be used over other Socket implementations.

(13 marks)

(Total: 25 marks)
1. Standard (TCP) Sockets:

- Objects Used:
  - ServerSocket
  - Socket
  - BufferedReader
  - PrintWriter

How it Works:
  - The ServerSocket object is used to create a server that listens for incoming connections on a specific port.
  - The Socket object represents the connection between the client and the server.
  - BufferedReader and PrintWriter objects are used to read from and write to the socket streams, enabling communication between the client and the server.

Circumstances:
  - Standard TCP sockets are used when a reliable, connection-oriented communication channel is required. This implementation ensures that data packets are delivered in the same order they were sent and without any loss, making it suitable for applications like chat applications, file transfers, and web servers.

```java
// Server
ServerSocket serverSocket = new ServerSocket(12345);
Socket clientSocket = serverSocket.accept();
BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);

// Client
Socket socket = new Socket("localhost", 12345);
BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
PrintWriter out = new PrintWriter(socket.getOutputStream(), true);
```

2. UDP Sockets (Datagram Sockets):

- Objects Used:
  - DatagramSocket
  - DatagramPacket

How it Works:
  - DatagramSocket is used for sending and receiving datagram packets over a network.
  - DatagramPacket represents the data packet to be sent or received.
  - Unlike TCP, UDP is connectionless and does not guarantee packet delivery, order, or error checking.

Circumstances:
  - UDP sockets are used when low-latency, connectionless communication is needed, and some data loss is acceptable. This implementation is suitable for applications like real-time video streaming, online gaming, and VoIP (Voice over Internet Protocol) where speed is crucial, and occasional data loss is tolerable.

```java
// Server
DatagramSocket serverSocket = new DatagramSocket(12345);
byte[] receiveBuffer = new byte[1024];
DatagramPacket receivePacket = new DatagramPacket(receiveBuffer, receiveBuffer.length);
serverSocket.receive(receivePacket);

// Client
DatagramSocket clientSocket = new DatagramSocket();
byte[] sendBuffer = "Hello".getBytes();
DatagramPacket sendPacket = new DatagramPacket(sendBuffer, sendBuffer.length, InetAddress.getByName("localhost"), 12345);
clientSocket.send(sendPacket);
```

3. Non-blocking (NIO) Sockets:

- Objects Used:
  - ServerSocketChannel
  - SocketChannel
  - Selector
  - ByteBuffer

How it Works:
  - ServerSocketChannel is a non-blocking channel for stream-oriented listening sockets.
  - SocketChannel is a non-blocking channel for stream-oriented connecting sockets.
  - Selector allows a single thread to manage multiple channels, handling I/O events such as connect, read, and write.
  - ByteBuffer is used for reading and writing data.

Circumstances:
  - Non-blocking NIO sockets are used in applications requiring high scalability and performance, especially where multiple connections need to be managed simultaneously. This implementation is ideal for servers that need to handle thousands of simultaneous connections, such as large-scale web servers and high-performance networking applications.
```java
// Server
ServerSocketChannel serverChannel = ServerSocketChannel.open();
serverChannel.socket().bind(new InetSocketAddress(12345));
serverChannel.configureBlocking(false);
Selector selector = Selector.open();
serverChannel.register(selector, SelectionKey.OP_ACCEPT);

// Client
SocketChannel clientChannel = SocketChannel.open(new InetSocketAddress("localhost", 12345));
ByteBuffer buffer = ByteBuffer.allocate(1024);
clientChannel.read(buffer);
```

- Explanation:
  - Standard (TCP) Sockets: Reliable, connection-oriented, guarantees delivery, suitable for applications needing accurate data transmission.
  - UDP Sockets (Datagram Sockets): Connectionless, does not guarantee delivery, suitable for real-time applications where speed is essential.
  - Non-blocking (NIO) Sockets: Allows for high scalability and performance by handling multiple connections with a single thread, suitable for high-traffic servers.

# Question 2
## Market Research Online System

A market research company requires an online system to allow users to review a particular product. The system requires the user to input their email, product name, and satisfaction level (number between 1 and 10). This information should be processed by a Servlet, returning a confirmation of the submission by displaying the data submitted by the user. Outline all the code required for the web application in question including all classes, webpages, and configuration files required. Use pointers to explain the code in detail.
(22 marks)
Servlet Lifecycle Methods

Outline the lifecycle methods of a Servlet and explain what each one does.

(3 marks)

(Total: 25 marks)

// Servlet Class
```java
import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;

public class ReviewServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // Get parameters from the request
        String email = request.getParameter("email");
        String product = request.getParameter("product");
        String satisfaction = request.getParameter("satisfaction");

        // Set response content type
        response.setContentType("text/html");

        // Write the response
        PrintWriter out = response.getWriter();
        out.println("<html><body>");
        out.println("<h2>Review Submitted</h2>");
        out.println("<p>Email: " + email + "</p>");
        out.println("<p>Product: " + product + "</p>");
        out.println("<p>Satisfaction Level: " + satisfaction + "</p>");
        out.println("</body></html>");
        out.close();
    }
}
```

Explanation:

- doPost(HttpServletRequest request, HttpServletResponse response): Handles POST requests.
- String email = request.getParameter("email");: Retrieves the email parameter from the request.
- response.setContentType("text/html");: Sets the response content type to HTML.
- PrintWriter out = response.getWriter();: Gets the writer to send response data back to the client.
- out.println("<html><body>");: Writes HTML content to the response.
- out.close();: Closes the writer.

// HTML Form page
```html
<!DOCTYPE html>
<html>
<head>
    <title>Product Review</title>
</head>
<body>
    <h1>Submit Your Review</h1>
    <form action="review" method="post">
        <label for="email">Email:</label><br>
        <input type="email" id="email" name="email" required><br><br>
        
        <label for="product">Product Name:</label><br>
        <input type="text" id="product" name="product" required><br><br>
        
        <label for="satisfaction">Satisfaction Level (1-10):</label><br>
        <input type="number" id="satisfaction" name="satisfaction" min="1" max="10" required><br><br>
        
        <input type="submit" value="Submit Review">
    </form>
</body>
</html>
```

Explanation:

- <form action="review" method="post">: Form submits data to the review endpoint using POST method.
- <input type="email" id="email" name="email" required>: Input field for email.
- <input type="text" id="product" name="product" required>: Input field for product name.
- <input type="number" id="satisfaction" name="satisfaction" min="1" max="10" required>: Input field for satisfaction level.
- <input type="submit" value="Submit Review">: Submit button to send the form data.

// Web Application Configuration (web.xml)
```xml
<!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd">
<web-app>
    <servlet>
        <servlet-name>ReviewServlet</servlet-name>
        <servlet-class>ReviewServlet</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>ReviewServlet</servlet-name>
        <url-pattern>/review</url-pattern>
    </servlet-mapping>
</web-app>
```

Explanation:

- <servlet>: Defines the servlet class.
- <servlet-name>ReviewServlet</servlet-name>: Names the servlet.
- <servlet-class>ReviewServlet</servlet-class>: Specifies the servlet class.
- <servlet-mapping>: Maps the servlet to a URL pattern.
- <url-pattern>/review</url-pattern>: URL pattern for accessing the servlet.

Directory Structure
- Web Content (webapp directory)
  - index.html: HTML form page for user input.
- WEB-INF/web.xml: 
  - Configuration file for the web application.
- Java Source (src directory)
    - ReviewServlet.java: Servlet handling the form submission.

Putting It All Together:

- The user accesses the index.html page, fills out the form, and submits it.
- The form data is sent to the ReviewServlet at the /review URL.
- The ReviewServlet processes the data, generates an HTML response, and displays the submitted review information to the user.


## Outline the lifecycle methods of a Servlet and explain what each one does.

The lifecycle of a servlet is managed by the servlet container (e.g., Apache Tomcat) and consists of the following stages, represented by specific methods:

- Initialization (init method)
- Request Handling (service method, doGet, doPost, etc.)
- Destruction (destroy method)

// Initialization (init method)
```java
public void init(ServletConfig config) throws ServletException {
    // Initialization code, e.g., resource allocation
}
```

- Purpose: The init method is called once when the servlet is first loaded into memory, typically when the servlet is first accessed, or at server startup if it is configured to load on startup.
- Tasks: Perform one-time initialization tasks, such as setting up database connections, reading configuration parameters, or initializing resources.
- Explanation: This method is executed only once during the servlet's lifecycle and is used to prepare the servlet for handling requests.

// Request Handling (service method, doGet, doPost, etc.)
```java
public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {
    // Common request handling code
}

protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    // Handle GET request
}

protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    // Handle POST request
}
```
- Purpose: The service method is called by the servlet container to handle each request. It determines the request type (e.g., GET, POST) and dispatches it to the appropriate method (doGet, doPost, etc.).
- Tasks: Process requests and generate responses. This may include reading request parameters, processing business logic, interacting with databases, and generating HTML responses.
- Explanation: The service method is the entry point for handling requests. For HTTP servlets, it's common to override doGet and doPost methods for GET and POST requests, respectively. The service method itself is rarely overridden directly.

// Destruction (destroy method)
```java
public void destroy() {
    // Cleanup code, e.g., resource deallocation
}
```
- Purpose: The destroy method is called once just before the servlet is removed from memory, typically when the server is shutting down or when the servlet container decides to unload the servlet.
- Tasks: Perform cleanup tasks, such as closing database connections, releasing resources, and saving state if necessary.
- Explanation: This method ensures that any resources allocated during the servlet's lifecycle are properly released to prevent resource leaks. 

Summary of Servlet Lifecycle Methods:

- init(ServletConfig config): Initializes the servlet and prepares it to handle requests.
- service(ServletRequest req, ServletResponse res): Handles each client request and dispatches it to the appropriate method based on the request type (GET, POST, etc.).
- destroy(): Cleans up resources before the servlet is unloaded from memory.

Lifecycle Flow:

- Initialization: The servlet container loads the servlet and calls the init method.
- Request Handling: For each request, the container calls the service method, which in turn calls doGet, doPost, etc., depending on the request type.
- Destruction: Before unloading the servlet, the container calls the destroy method to perform any necessary cleanup.

By understanding and correctly implementing these lifecycle methods, developers can ensure that their servlets efficiently manage resources and handle client requests effectively.
